/*
 *   Copyright (c) 2013, 2014, Pyhrol, pyhrol@rambler.ru
 *   GEO: N55.703431,E37.623324 .. N48.742359,E44.536997
 * 
 *   Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions
 *   are met:
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *   4. Neither the name of the Pyhrol nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 * 
 *   THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 *   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *   ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 *   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 *   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *   SUCH DAMAGE.
 */

// $Date: 2014-02-27 22:19:34 +0400 (Thu, 27 Feb 2014) $
// $Revision: 896 $

#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <time.h>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <stdexcept>
#include <fstream>

#include "strings_manip.h"

using namespace std;

const string
    mode_default = "1"
  , name_prefix = "PYHROL"
;
const size_t num_default = 8;

void usage(const char *me)
{
  cout
    << "This is macro generator for \"C++ -> Python\" wrapper" << endl
    << "Usage: " << me << " [Options]" << endl
    << "Options are:" << endl
    << "  -C - show comment with this utility name and timestamp" << endl
    << "  -L - license file" << endl
    << "  -N - number, mode specific, default " << num_default << endl
    << "  -m - mode (test name), default " << mode_default << ":" << endl
    << "    1 - macro_parse_generation([-N])" << endl
    << "    2 - macro_build_generation([-N])" << endl
    << "  -h - print this help and exit" << endl
  ;
}

void show_license(const string &license)
{
  ifstream ifs;
  ifs.open(license.c_str());
  if (ifs.is_open())
  {
    cout
      << "/*" << endl
    ;
    while (!ifs.eof())
    {
      string line;
      getline (ifs, line);
      cout
        << " * " << line << endl
      ;
    }
    cout
      << " */" << endl
      << endl
    ;
  }
  else
  {
    cout
      << "/* " << endl
      << " * Failed to open file `" << license << "`" << endl
      << " * License agreement unavailable" << endl
      << " * Try file LICENSE in the root of source archive" << endl
      << " */" << endl
      << endl
    ;
  }
}

void show_comment(int argc, char *argv[])
{
  const time_t __t = time(NULL);
  tm __tm;
  localtime_r (&__t, &__tm);
  cout
    << "// Generated by `" << argv[0] << "` at "
    << setfill('0')
    << setw(4) << right << __tm.tm_year + 1900
    << '-' << setw(2) << right << __tm.tm_mon + 1
    << '-' << setw(2) << right << __tm.tm_mday
    << ' ' << setw(2) << right << __tm.tm_hour
    << ':' << setw(2) << right << __tm.tm_min
    << ':' << setw(2) << right << __tm.tm_sec
    << setfill(' ')
    << endl
  ;
  if (argc > 1)
  {
    cout << "// Options: {";
    for (int pos = 1; pos != argc; pos ++)
    {
      cout << (pos == 1 ? "\"" : "\", \"") << argv[pos];
    }
    cout
      << "\"}" << endl
      << endl
    ;
  }
}

void macro_parse_generation(const size_t num)
{
  for (size_t i = 0; i <= num; i ++)
  {
    cout << "#define " << name_prefix << "_PARSE_TUPLE";
/*    if (with_keywords)
    {
      cout << "_WITH_KEYWORDS";
    }*/
    cout << "_" << i << "(description";
    cout << ", container";
    for (size_t j = 1; j <= i; j ++)
    {
      cout << ", arg" << j;
    }
    cout
      << ")\\" << endl
      << "  if (container.prepare_parse(description))\\" << endl
      << "  {\\" << endl
    ;
    for (size_t j = 1; j <= i; j ++)
    {
      cout
        << "    container.t_in().add(&arg" << j << ", __STRING(arg" << j << "));\\" << endl
      ;
    }
    if (!i)
    {
      cout
        << "    container.t_in();\\" << endl
      ;
    }
    cout
      << "  }\\" << endl
      << "  if (container.is_parse_enabled())\\" << endl
      << "  {\\" << endl
      << "    container.parse(true";
    for (size_t j = 1; j <= i; j ++)
    {
      cout << ", &arg" << j;
    }
    cout
      << ");\\" << endl
      << "  }" << endl
      << endl
    ;
  }
}

void macro_build_generation(const size_t num)
{
  for (size_t i = 0; i <= num; i ++)
  {
    cout << "#define " << name_prefix << "_BUILD_VALUE_" << i << "(description, container";
    for (size_t j = 1; j <= i; j ++)
    {
      cout << ", arg" << j;
    }
    cout
      << ")\\" << endl
      << "  if (container.prepare_build(description))\\" << endl
      << "  {\\" << endl
    ;
    for (size_t j = 1; j <= i; j ++)
    {
      cout
        << "    container.t_out().add(arg" << j << ", __STRING(arg" << j << "));\\" << endl
      ;
    }
    if (!i)
    {
      cout
        << "    container.t_out();\\" << endl
      ;
    }
    cout
      << "  }\\" << endl
      << "  if (container.is_build_enabled())\\" << endl
      << "  {\\" << endl
      << "    container.build(true";
    for (size_t j = 1; j <= i; j ++)
    {
      cout << ", arg" << j;
    }
    cout
      << ");\\" << endl
      << "  }" << endl
      << endl
    ;
  }
}

int main(int argc, char *argv[])
{
  int ret_val = EXIT_FAILURE;
  bool comment = false;
  size_t num = num_default;
  string
      license
    , mode = mode_default
  ;
  char ch;

  try
  {
    while ((ch = getopt(argc, argv, "CL:N:m:h")) != -1)
    {
      switch (ch)
      {
        case 'C':
          comment = true;
          break;
        case 'L':
          license = optarg;
          break;
        case 'N':
          num = c_string_to_uint(optarg);
          break;
        case 'm':
          mode = optarg;
          break;
        case 'h':
        case '?':
        default:
          usage(argv[0]);
          return ret_val;
      }
    }

    if (license.length())
    {
      show_license(license);
    }

    if (comment)
    {
      show_comment(argc, argv);
    }

    if (mode == "1")
    {
      macro_parse_generation(num);
    }
    else if (mode == "2")
    {
      macro_build_generation(num);
    }
    else
    {
      ostringstream ostr;
      ostr << "Mode \"" << mode << "\" invalid";
      throw runtime_error(ostr.str());
    }
    ret_val = EXIT_SUCCESS;
  }
  catch (const runtime_error &rerr)
  {
    cerr
      << "*** std::runtime_error! " << rerr.what() << endl
    ;
  }
  catch (const logic_error &lerr)
  {
    cerr
      << "*** std::logic_error! " << lerr.what() << endl
    ;
  }
  catch (const exception &ex)
  {
    cerr
      << "*** std::exception! " << ex.what() << endl
    ;
  }
  catch (...)
  {
    cerr
      << "*** Fatal! Uncaught exception" << endl
    ;
  }
  return ret_val;
}

